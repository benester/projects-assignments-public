defmodule Cmplx do
    #returns the complex number with real value and imaginary
    def new(r, i) do  
        {r, i}
    end
    #adds two complex numbers
    def add(a, b)do
        {ra, ia} = a
        {rb, ib} = b
        {ra + rb, ia + ib}
    end
    #squares a complex number
    def sqr(a) do 
        {r, i} = a
        {(r*r) - (i*i), (r*i)+(r*i)}
    end
    #the absolute value of
    def abs(a)do 
        {r, i} = a
        :math.sqrt(:math.pow(r,2) + :math.pow(i,2))
    end  
end

defmodule Brot do
    def mandelbrot(c, m) do
        z0 = Cmplx.new(0 , 0)
        {zr, zi} = z0
        {cr, ci} = c
        i = 0
        test(i, zr, zi, cr, ci, m)
    end

    def test(m, _Zr, _Zi, _Cr, _Ci, m) do 0 end
    def test(i, zr, zi, cr, ci, m) do  
        zr2 = zr * zr
        zi2 = zi * zi
        a2 = :math.sqrt(zr2 + zi2)
        cond do 
            a2 < 2.0
                ->
                sr = zr2 - zi2 + cr
                si = 2*zr*zi + ci
                test(i+1, sr, si, cr, ci, m)
            true
                -> i
        end
    end
end

defmodule Color do
    def convert(depth, max) do 
        fracA = (depth / max) * 4
        fracX = trunc(fracA)
        fracY = trunc(255 * (fracA - fracX))
        cond do 
            fracX == 0 -> {:rgb, fracY, 0, 0}
            fracX == 1 -> {:rgb, 255, fracY,0}
            fracX == 2 -> {:rgb, 255-fracY, 255, 0}
            fracX == 3 -> {:rgb, 0, 255, fracY}
            fracX == 4 -> {:rgb, 0, 255 - fracY, 255}
        end
    end
end

defmodule Mandel do

    def mandelbrot(width, height, x, y, k, depth) do
        trans = fn(w,h) ->
            Cmplx.new(x + k * (w - 1), y - k * (h - 1))
        end
        rows(width, height, trans, depth, [])
    end
    defp rows(_, 0, _, _, rows), do: rows
    defp rows(w, h, tr, depth, rows) do
        row = row(w, h, tr, depth, [])
        rows(w, h - 1, tr, depth, [row | rows])
    end

    defp row(0, _, _, _, row), do: row
    defp row(w, h, tr, depth, row) do
        c = tr.(w, h)
        res = Brot.mandelbrot(c, depth)
        color = Color.convert(res, depth)
        row(w - 1, h, tr, depth, [color | row])
    end
end

defmodule Demo do
    def demo() do
        small(-1, 1, -0.4)
    end

    #Det komplexa talet (x0, y0i) med right edge xn
    def small(x0, y0, xn) do
        width = 1920
        height = 1080
        depth = 255    #Hur länge ska mandelbrot algoritmen köra, innan den ger upp.
        k = (xn - x0) / width   #Avståndet mellan pixlar
        image = Mandel.mandelbrot(width, height, x0, y0, k, depth)
        PPM.write("small.ppm", image)
    end
end

defmodule Depth do 
  ### Ensure that the init() routine is called when module loaded. 
  @on_load :init

  ### This init() routine must only be called once.

  def init() do 
    :ok = :erlang.load_nif("./depth", 0)
  end

  @doc """
  The function test(r, i, m) : calculate the mandelbrot value of
  complex value {r,i}, with a maximum iteration of m. Returns a value
  in the range 0..(m-1). The depth needs to be > 0.
  """
  @spec test(float(), float(), integer()) :: integer()

  ### If the loding failed this dummy function is used. 
  def test(_r, _i, _m) do
    exit(:nif_library_not_loaded)
  end
end

defmodule PPM do

  # write(name, image) The image is a list of rows, each row a list of
  # tuples {R,G,B}. The RGB values are 0-255.

  def write(name, image) do
    height = length(image)
    width = length(List.first(image))
    {:ok, fd} = File.open(name, [:write])
    IO.puts(fd, "P6")
    IO.puts(fd, "#generated by ppm.ex")
    IO.puts(fd, "#{width} #{height}")
    IO.puts(fd, "255")
    rows(image, fd)
    File.close(fd)
  end

  defp rows(rows, fd) do
    Enum.each(rows, fn(r) ->
      colors = row(r)
      IO.write(fd, colors)
    end)
  end

  defp row(row) do
    List.foldr(row, [], fn({:rgb, r, g, b}, a) ->
      [r, g, b | a]
    end)
  end
end